<!DOCTYPE html>
<html>

<head>
    <meta name="google" value="notranslate">
    <title>Flocking</title>
    <link href="flock.css" type="text/css" rel="stylesheet" />
    <script src="bower_components/d3/d3.js"></script>
    <script src="build/main.js"></script>

</head>

<body>
    <div id="container">
        <div id="title" class="text">
            <center>
                <h1>Flocking</h1>
            </center>
            <center>
                <h3> by Dan Mané</h3>
            </center>
            <center>
                <span> Controls: </span>
                <button id="killAll"> Kill All Boids </button>
                <button id="addFlocking"> Add Flocking Prey </button>
                <button id="addNonFlocking"> Add Non-Flocking Prey </button>
                <button id="addPredator"> Add Predator</button>
            </center>
        </div>
        <div id="outer"></div>
        <div id="text-container" class="text">
            <p>This is a simulation that combines predator/prey dynamics, the flocking algorithm, and natural selection. </p>

            <h2>The Boids</h2>

            <p>The creatures that move across the screen are called "Boids". Boids can see aspects of their environment, move around, eat, reproduce, and die. There are two types: herbivores and carnivores. The herbivores graze on slowly-regenerating plant matter, and the carnivores eat the herbivores.</p>

            <h2>Flocking</h2>

            <p>The boids move around with intelligent and intentional-seeming behavior: the herbivores generally try to stick together in groups and avoid carnivores, while the carnivores try to catch them. All of this behavior is powered by a single simple algorithm, called <a href="http://en.wikipedia.org/wiki/Flocking_%28behavior%29">flocking</a>. </p>

            <p>The canonical algorithm works as follows: each boid tries to maintain a minimum <em>seperation distance</em> away from other boids, tries to <em>cohere</em> with the group of nearby boids by moving towards the center of the group, and tries to <em>align</em> with the group by moving towards its heading. The relative strengths of each of these behaviors is controlled by a weight.</p>

            <p>For this simulation, I generalized the traditional approach to allow for interspecies dynamics. Each boid runs the flocking algorithm three times on three different inputs. First, on nearby herbivores; second, on nearby carnivores; third, on the single closest boid. This allows for the interspecies behavior in the simulation: herbivores have a high <em>seperation distance</em> to carnivores, so they will try to stay away. Carnivores, however, have a negative <em>seperation weight</em> for herbivores, so they will try to accelerate towards prey that is close to them. I added the "closest boid" computation to allow carnivores to zero in on a single target when surrounded by a group of prey. Without this accomodation, carnivores would get confused like <a href="http://en.wikipedia.org/wiki/Buridan%27s_ass">Burdian's ass</a>: when between two equally tasty pieces of prey, it would be unable to choose between them, and would starve to death. </p>

            <p>This generalized flocking algorithm has 12 free parameters. The exact parameters are specific to each boid, encoded in their genetics. Thus, the system can potentially evolve into different behaviors over time. One thing I want to experiment with is whether a simulation that starts with non-flocking behavior will naturally evolve towards flocking as a response to predation.</p>

            <h2>The Circle of Life</h2>

            <p>Every boid has a certain amount of food stored it its body. If the food reaches zero, it starves and dies. If it has a high level of food, then it will reproduce. Reproduction is sexual: the boid will mate with the nearest boid of its own species. Their genetics are then mixed together.</p>

            <p>As boids grow older, they 'age' and slow down. Older herbivores will have trouble escaping predators and grazing, while older predators will have trouble catching prey.</p>

            <h2>Implementation Details</h2>

            <p>First things first, you can find the source code <a href="https://github.com/danmane/predator-flocks">on Github</a>. This program is written in Typescript, and uses a mixture of SVG and Canvas as rendering technologies. </p>

            <h3>Overall Architecture</h3>

            <p>It has a fairly standard OO-style architecture for the simulation. There is a <a href="https://github.com/danmane/predator-flocks/blob/master/src/world.ts">world</a> object that contains all of the <a href="https://github.com/danmane/predator-flocks/blob/master/src/boid.ts">boids</a> as well as information on <a href="https://github.com/danmane/predator-flocks/blob/master/src/foodBackground.ts">where the food is</a> and a <a href="https://github.com/danmane/predator-flocks/blob/master/src/gridNeighborDetector.ts">spatial datastructure</a> for finding nearby boids quickly. When <code>world.step()</code> is called, it:</p>

            <ol>
                <li>Updates the spatial data structure (GridNeighborDetector)</li>
                <li>Has each boid compute its own acceleration using the flocking algorithm</li>
                <li>Has each boid compute its new position, based on its acceleration</li>
                <li>Has each herbivore eat the food it is currently standing on</li>
                <li>Has each predator eat the herbivores it is currently touching</li>
                <li>Has each boid use up a bit of its own food, then reproduce or die according to how much food it has</li>
            </ol>

            <h3>Neighbor Detection</h3>

            <p>The flocking algorithm requires that each <code>boid</code> know the position of the <code>NUM_NEIGHBORS_TO_SHOW</code> nearest <code>boid</code>s of its species. If implemented naively, this is an <code>O(n)</code> computation since we need to check every other boid, and since there are <code>n</code> boids, the total runtime is <code>O(n^2)</code>. In practice, this makes a major perf bottleneck. To solve this, I decided to use a spatial data structure that would enable faster queries to find boids in the neighborhood of a given cell. I first considered using a <a href="http://en.wikipedia.org/wiki/Quadtree">quadtree</a> or <a href="http://en.wikipedia.org/wiki/R-tree">r-tree</a>. These both could have worked, (in particular the r-tree seems a good fit for nearest neighbor detection) but I instead decided to use a simpler solution which was much faster to implement. The solution is to partition the space into a rectangular grid, so that the width of a cell is equal to <code>NEIGHBOR_RADIUS</code>, the maximum distance at which boids can be considered neighbors. Then, if we retrieve all of the boids in adjacent cells (the <a href="http://en.wikipedia.org/wiki/Moore_neighborhood">Moore neighborhood</a>) we have a strict superset of of boids that are potential nearest neighbors and we can find the nearest neighbor through the naïve approach. This is still <code>O(n^2)</code> in the worst case (if neighbor radius is very large, or the boids are clumped together) but in practice the performance was much better. This approach is explained in more details (with diagrams!) <a href="https://mofanim.wordpress.com/2010/10/27/optimized-boids-i/">here</a>. </p>

            <h3>Tracking the Food</h3>

            <p>The green plant material in the background is actually tracked at the pixel level, so right now there are >500,000 separate food values being maintained. For efficiency reasons, we never actually iterate over the netire set of food values for either the model update or rendering. The food values are stored in <a href="https://github.com/danmane/predator-flocks/blob/master/src/foodBackground.ts">foodBackground.ts</a> as a map storing, for each coordinate, the last time at which a grazer ate the food there. Since food regenerates at a constant rate, to compute the current food value at a cell, we just calculate the number of timesteps that have passed since the last time it was grazed. </p>

            <h3>Rendering</h3>

            <p>The renderer is actually a mash-up of two different technologies: <a href="http://en.wikipedia.org/wiki/Scalable_Vector_Graphics">svg</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">canvas</a>. The boids are drawn as svg circles using <a href="http://d3js.org/">D3.js</a>; I used D3 for this because it is powerful and I know it well, so it let me prototype rendering very quickly. However, since it requires mutating the DOM it's not as efficient as canvas, so later I may switch the boid renderer over to canvas.</p>

            <p>Rendering the food background is a bit more tricky. For obvious reasons, I didn't want to iterate over 500,000 values for rendering each frame. Instead, I render a translucent green background periodically, and then draw small white circles over areas that have just been eaten by a herbivore. The result is that herbivores leave white paths in the background, and these paths slowly fade to green. </p>
        </div>

    </div>

</body>

</html>
